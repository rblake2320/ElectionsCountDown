 Complete Database Architecture & Caching Strategy for Congressional Data:

  Tell Replit to implement this exact database and caching system:

  1. DATABASE SCHEMA - Store Everything Locally

  -- MEMBERS TABLE (Core data that rarely changes)
  CREATE TABLE congress_members (
    bioguide_id VARCHAR(20) PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    state VARCHAR(2) NOT NULL,
    district INTEGER, -- NULL for senators
    party VARCHAR(50),
    chamber ENUM('House', 'Senate'),
    photo_url VARCHAR(500),
    office_address TEXT,
    phone VARCHAR(20),
    website VARCHAR(200),
    social_media JSONB, -- {twitter: '', facebook: ''}
    committee_assignments JSONB, -- Array of committee IDs
    years_served INTEGER,
    next_election DATE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
  );

  -- BILLS TABLE (Update daily)
  CREATE TABLE congress_bills (
    bill_id VARCHAR(50) PRIMARY KEY, -- e.g., "hr1234-118"
    congress INTEGER NOT NULL,
    bill_number VARCHAR(20),
    title TEXT,
    short_title VARCHAR(500),
    sponsor_id VARCHAR(20) REFERENCES congress_members(bioguide_id),
    introduced_date DATE,
    last_action_date DATE,
    last_action TEXT,
    status VARCHAR(50), -- introduced, committee, passed_house, etc.
    subjects JSONB, -- Array of subject tags
    cosponsors JSONB, -- Array of bioguide_ids
    committee_codes JSONB, -- Array of committee codes
    text_url VARCHAR(500),
    summary TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
  );

  -- VOTES TABLE (Update after each vote)
  CREATE TABLE congress_votes (
    vote_id VARCHAR(50) PRIMARY KEY,
    congress INTEGER,
    chamber VARCHAR(10),
    vote_number INTEGER,
    vote_date TIMESTAMP,
    question TEXT,
    vote_type VARCHAR(50),
    required_majority VARCHAR(20),
    result VARCHAR(20), -- Passed, Failed, Agreed to
    bill_id VARCHAR(50) REFERENCES congress_bills(bill_id),
    yea_total INTEGER,
    nay_total INTEGER,
    present_total INTEGER,
    not_voting_total INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
  );

  -- MEMBER_VOTES TABLE (How each member voted)
  CREATE TABLE member_votes (
    vote_id VARCHAR(50) REFERENCES congress_votes(vote_id),
    member_id VARCHAR(20) REFERENCES congress_members(bioguide_id),
    vote_position VARCHAR(20), -- Yea, Nay, Present, Not Voting
    PRIMARY KEY (vote_id, member_id)
  );

  -- COMMITTEES TABLE
  CREATE TABLE congress_committees (
    committee_code VARCHAR(10) PRIMARY KEY,
    name VARCHAR(200),
    chamber VARCHAR(10),
    type VARCHAR(50),
    parent_committee VARCHAR(10),
    jurisdiction TEXT,
    created_at TIMESTAMP DEFAULT NOW()
  );

  -- API_CACHE TABLE (For expensive API calls)
  CREATE TABLE api_cache (
    cache_key VARCHAR(500) PRIMARY KEY,
    endpoint VARCHAR(200),
    response_data JSONB,
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
  );

  -- Create indexes for performance
  CREATE INDEX idx_bills_congress ON congress_bills(congress);
  CREATE INDEX idx_bills_status ON congress_bills(status);
  CREATE INDEX idx_bills_sponsor ON congress_bills(sponsor_id);
  CREATE INDEX idx_bills_action_date ON congress_bills(last_action_date);
  CREATE INDEX idx_votes_date ON congress_votes(vote_date);
  CREATE INDEX idx_votes_congress ON congress_votes(congress);
  CREATE INDEX idx_member_state ON congress_members(state);
  CREATE INDEX idx_member_party ON congress_members(party);
  CREATE INDEX idx_cache_expires ON api_cache(expires_at);

  2. SMART CACHING STRATEGY

  class CongressDataService {
    // Check cache first, then database, then API
    async getMembers(filters = {}) {
      const cacheKey = `members:${JSON.stringify(filters)}`;

      // 1. Check memory cache (Redis/in-memory)
      const cached = await this.checkMemoryCache(cacheKey);
      if (cached) return cached;

      // 2. Check database
      let query = db.select().from(congressMembers);
      if (filters.state) query = query.where('state', filters.state);
      if (filters.party) query = query.where('party', filters.party);

      const dbResults = await query;

      // 3. If database is empty or stale, fetch from API
      if (dbResults.length === 0 || this.isDataStale('members')) {
        await this.syncMembersFromAPI();
        return this.getMembers(filters); // Recursive call with fresh data
      }

      // 4. Cache the results
      await this.setMemoryCache(cacheKey, dbResults, 3600); // 1 hour
      return dbResults;
    }

    async getBills(filters = {}) {
      const cacheKey = `bills:${filters.congress}:${JSON.stringify(filters)}`;

      // For recent bills, check if we need updates
      if (this.needsBillUpdate(filters.congress)) {
        await this.syncRecentBills(filters.congress);
      }

      // Query from database with filters
      let query = db.select().from(congressBills);
      if (filters.congress) query = query.where('congress', filters.congress);
      if (filters.status) query = query.where('status', filters.status);
      if (filters.sponsor_id) query = query.where('sponsor_id', filters.sponsor_id);

      return query.orderBy('last_action_date', 'desc');
    }

    // Intelligent sync - only fetch what's changed
    async syncMembersFromAPI() {
      const lastSync = await this.getLastSyncTime('members');

      // Full sync weekly, incremental daily
      if (!lastSync || daysSince(lastSync) > 7) {
        await this.fullMemberSync();
      } else {
        await this.incrementalMemberSync(lastSync);
      }
    }

    async fullMemberSync() {
      console.log('Starting full member sync...');
      const allMembers = [];
      let offset = 0;

      while (true) {
        const response = await fetch(
          `https://api.congress.gov/v3/member?api_key=${API_KEY}&limit=250&offset=${offset}`
        );
        const data = await response.json();

        if (!data.members?.length) break;
        allMembers.push(...data.members);

        if (!data.pagination?.next) break;
        offset += 250;

        // Rate limiting
        await sleep(100);
      }

      // Bulk insert with upsert
      await db.insert(congressMembers)
        .values(allMembers.map(m => ({
          bioguide_id: m.bioguideId,
          name: m.name,
          state: m.state,
          party: m.partyName,
          chamber: m.terms?.item?.[0]?.chamber,
          photo_url: m.depiction?.imageUrl,
          updated_at: new Date()
        })))
        .onConflictDoUpdate({
          target: congressMembers.bioguide_id,
          set: { updated_at: new Date() }
        });

      await this.setLastSyncTime('members');
      console.log(`Synced ${allMembers.length} members`);
    }

    // Cache expensive aggregations
    async getMemberStats(memberId) {
      const cacheKey = `member_stats:${memberId}`;
      const cached = await this.getCached(cacheKey);
      if (cached) return cached;

      // Calculate expensive stats
      const stats = {
        totalBillsSponsored: await db.count()
          .from(congressBills)
          .where('sponsor_id', memberId),
        votingAttendance: await this.calculateAttendance(memberId),
        partyUnityScore: await this.calculatePartyUnity(memberId),
        committeesCount: await this.getCommitteeCount(memberId)
      };

      // Cache for 24 hours
      await this.setCached(cacheKey, stats, 86400);
      return stats;
    }

    // Smart cache invalidation
    async invalidateRelatedCaches(entity, id) {
      switch(entity) {
        case 'bill':
          await this.invalidate(`bills:*`);
          await this.invalidate(`member_stats:${bill.sponsor_id}`);
          break;
        case 'vote':
          await this.invalidate(`votes:*`);
          await this.invalidate(`member_stats:*`);
          break;
      }
    }
  }

  3. BACKGROUND SYNC JOBS

  // Set up cron jobs for automatic updates
  class CongressSyncScheduler {
    setupJobs() {
      // Every 5 minutes - check for new votes
      cron.schedule('*/5 * * * *', async () => {
        await this.syncRecentVotes();
      });

      // Every hour - update bill statuses
      cron.schedule('0 * * * *', async () => {
        await this.syncBillUpdates();
      });

      // Daily at 2 AM - full member sync
      cron.schedule('0 2 * * *', async () => {
        await this.fullMemberSync();
      });

      // Weekly - clean old cache entries
      cron.schedule('0 3 * * 0', async () => {
        await db.delete().from(apiCache)
          .where('expires_at', '<', new Date());
      });
    }

    async syncRecentVotes() {
      // Only fetch votes from last 24 hours
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);

      const recentVotes = await this.fetchVotesSince(yesterday);
      if (recentVotes.length > 0) {
        await this.saveVotes(recentVotes);
        await this.invalidateVotesCaches();
      }
    }
  }

  4. API RESPONSE CACHING

  // Middleware to automatically cache API responses
  const cacheMiddleware = (duration = 300) => async (req, res, next) => {
    const cacheKey = `api:${req.originalUrl}`;

    // Check cache first
    const cached = await getCached(cacheKey);
    if (cached) {
      res.setHeader('X-Cache', 'HIT');
      return res.json(cached);
    }

    // Store original json method
    const originalJson = res.json;
    res.json = function(data) {
      // Cache the response
      setCached(cacheKey, data, duration);
      res.setHeader('X-Cache', 'MISS');
      originalJson.call(this, data);
    };

    next();
  };

  // Apply to routes
  app.get('/api/members', cacheMiddleware(3600), getMembersHandler);
  app.get('/api/bills', cacheMiddleware(300), getBillsHandler);
  app.get('/api/votes', cacheMiddleware(60), getVotesHandler);

  5. USAGE EXAMPLES

  // Users request members - instant response from cache/DB
  GET /api/members?state=CA
  - Check memory cache (< 1ms)
  - If miss, check database (< 10ms)
  - If empty, sync from API then return (< 5s first time only)

  // Users track a bill - real-time updates
  GET /api/bills/hr1234-118
  - Return from database immediately
  - Background job checks for updates every hour
  - WebSocket notification if status changes

  // Expensive aggregation - cached for performance
  GET /api/members/H001089/stats
  - First request: Calculate and cache (500ms)
  - Subsequent requests: Return from cache (< 5ms)

  Tell Replit:
  "Implement this complete database schema and caching system. Key points:
  1. Store all data locally in PostgreSQL
  2. Use memory cache for frequent queries
  3. Background jobs sync changes automatically
  4. API calls only happen when data is missing or stale
  5. Cache expensive calculations for 24 hours
  6. Users get instant responses, not API wait times

  Start by creating all these tables, then implement the sync functions to populate them with all 535+ members."